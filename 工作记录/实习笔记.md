# 实习笔记

## windows驱动开发

> 环境：vs2019 + VMware-win7(kdm manager + debugview) + win7串口调试
> win10 SDK+WDK

### 环境配置

#### 开发环境

- WDK会自动安装VS插件，但实际在安装时没有自动安装，解决办法为从安装目录下找到插件手动安装
- 需要修改win7的注册表文件，在`HKLM\SYSTEM\CuurentControlSet\Control\Session Manager`下创建或打开`Debug Print Filter`，创建项`DEFAULT`，值为0xf

```reg
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Debug Print Filter] 
"DEFAULT"=dword:0000000f
```

- 新建WDM项目后，进行如下默认属性修改：
  - 链接器：将链接器警告视为错误 -> 否
  - Driver Settings：目标OS版本 -> windows 7；目标平台 -> Desktop
  - Inf2Cat：Run Inf2Cat -> 否
  - C/C++ -- 常规：警告等级 -> W3；将警告视为错误：否

- 注意源码文件后缀设置为.c
- 开发win7下win32应用需要VS安装.NET 3.5的开发工具包
- VS2019开发旧版本（XP、win7）win32程序配置：
  - C/C++ -> 语言 -> 符合模式 -> 否
  - 常规 -> 平台工具集 -> Visual Studio 2017 - Windows XP (v141_xp)
  - C/C++ -> 代码生成 -> 运行库 -> 多线程(/MT) *对应debug版用多线程调试(/MTd)*

#### 调试环境

1. 为win7虚拟机添加串口设备（虚拟机设置里），记住端口号，默认应该是2（1是打印机，也可以删掉打印机，用1表示串口）
2. 在win7下cmd输入`bcdedit /copy {current} /d DebugEntry`，这里的DebugEntry可以随意替换名称
3. 打开msconfig--引导，配置DebugEntry的引导高级选项，勾选调试，设置调试端口为前面设置的端口号，波特率默认115200即可，设置好后重启选择系统即可进入调试模式
4. 创建调试机下windbg快捷方式，添加启动参数，如`"C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\windbg.exe" -b -k com:pipe,port=\\.\pipe\com_1,resets=0,reconnect -y`
5. 之后启动windbg等待连接即可

### 驱动基础

#### 写文件

```c
#include <ntddk.h>

VOID DriverUnload(PDRIVER_OBJECT pDriver){
    UNREFERENCED_PARAMETER(pDriver);
    DbgPrint("=====Driver unload success=====\n");
}

NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pRegPath){
    DbgPrint("=====Driver load success=====\n");
    HANDLE hFile = NULL;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS ntStatus;

    ////创建对象
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING file_path;
    RtlInitUnicodeString(&file_path, L"\\??\\c:\\test.log");
    ////初始化对象
    InitializeObjectAttributes(&oa, &file_path, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

    ////创建文件
    ntStatus = ZwCreateFile(
        &hFile,
        GENERIC_READ | GENERIC_WRITE,
        &oa,
        &ioStatus,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ,
        FILE_OPEN_IF,
        FILE_NON_DIRECTORY_FILE | FILE_RANDOM_ACCESS |  FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0);

    ////写文件
    ntStatus = ZwWriteFile(
        hFile,
        NULL,
        NULL,
        NULL,
        &ioStatus,
        file_path.Buffer,
        file_path.Length,
        NULL,
        NULL
    );
    ZwClose(hFile);
    DbgPrint("=====Create file success=====\n");
    pDriver->DriverUnload = DriverUnload;
    return STATUS_SUCCESS;
}
```

#### DeviceIoControl练习

子系统及其本机应用程序只能通过 i/o 管理器提供的**文件对象句柄**访问驱动程序的设备或大容量存储设备上的文件。 若要打开此类文件对象或获取设备或数据文件的 i/o 句柄，子系统将**使用请求打开命名文件来调用 i/o 系统服务**。 命名文件可以具有特定于子系统的别名 (符号链接) 到 file 对象的内核模式名称。

##### 定义ctl码

```c
#define CTL_CODE(DeviceType, Function, Method, Access) (((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method))
```

- DeviceType：设备类型，IoCreateDevice使用的设备类型
- Function：定义设备类别中的一个操作。0-2047和4096以后被微软保留，2048-4095（0x800-0xFFF）可用
- Method：定义操作模式
  - METHOD_BUFFERED：缓冲区方法
  - METHOD_IN_DIRECT：直接输入
  - METHOD_OUT_DIRECT：直接输出
  - METHOD_NEITHER：两者都不，即其他方法
  - 对于 Windows 嵌入式设备，此字段将被忽略。始终使用 METHOD_BUFFERED。
- Access：一般用FILE_ANY_ACCESS，所有权限。

##### 基本概念

`PDEVICE_OBJECT DeviceObject`：指向第一个设备对象的指针。一个驱动可以创建多个“设备”，这个成员是指向第一个设备对象的指针。驱动程序可以使用此成员和 DEVICE_OBJECT 的 NextDevice 成员来逐句通过驱动程序创建的所有设备对象的列表。
`UNICODE_STRING DriverName`：驱动名称，是 UNICODE_STRING 字符串。
`PDRIVER_DISPATCH MajorFunction`：派遣函数的指针。应视作一个数组，用以注册派遣函数，
`PDRIVER_UNLOAD DriverUnload`：驱动卸载函数的指针。指向一个卸载函数，驱动卸载时负责清理工作，应在这个函数中关闭打开的句柄、释放申请的内存，防止内存泄露。如果驱动程序不注册卸载函数，那么驱动一旦加载就无法卸载。

##### 驱动部分

```c
#include <ntddk.h>

#define IOCTL1 CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL2 CTL_CODE(FILE_DEVICE_UNKNOWN,0x801,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL3 CTL_CODE(FILE_DEVICE_UNKNOWN,0x802,METHOD_BUFFERED,FILE_ANY_ACCESS)

typedef struct _DEVICE_EXTENSION {
    UNICODE_STRING SymLinkName;
} DEVICE_EXTENSION, * PDEVICE_EXTENSION;

VOID DriverUnload(PDRIVER_OBJECT pDriverObject) {
    PDEVICE_OBJECT pDevObj;
    pDevObj = pDriverObject->DeviceObject; // 

    PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)pDevObj->DeviceExtension;//得到设备扩展

    //删除符号链接
    UNICODE_STRING pLinkName = pDevExt->SymLinkName;
    IoDeleteSymbolicLink(&pLinkName);

    //删除设备
    IoDeleteDevice(pDevObj);

    DbgPrint("======Driver Unload!======");
}

NTSTATUS DefaultDispatchRoutine(PDEVICE_OBJECT pDevObj, PIRP pIrp)
{
    NTSTATUS status = STATUS_SUCCESS;
    pIrp->IoStatus.Status = status;
    pIrp->IoStatus.Information = 0;
    // 当驱动完成了对指定IRP的所有处理操作之后，会调用 IoCompleteRequest
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    return status;
}

NTSTATUS IoctlDispatchRoutine(PDEVICE_OBJECT pDevObj, PIRP pIrp)
{
    DbgPrint("Enter IoctlDispatchRoutine\r\n");
    NTSTATUS status = STATUS_SUCCESS;

    //得到I/O堆栈的当前这一层，也就是IO_STACK_LOCATION结构的指针
    PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(pIrp);

    ULONG in_size = stack->Parameters.DeviceIoControl.InputBufferLength;//得到输入缓冲区的大小
    ULONG out_size = stack->Parameters.DeviceIoControl.OutputBufferLength;//得到输出缓冲区的大小
    ULONG code = stack->Parameters.DeviceIoControl.IoControlCode;//得到控制码

    PVOID buffer = pIrp->AssociatedIrp.SystemBuffer;//得到缓冲区指针

    switch (code)
    {                        // process request
    case IOCTL1:
        DbgPrint("======Got Code 1======");
    case IOCTL2:
        DbgPrint("======Got Code 2======");
    case IOCTL3:
        DbgPrint("======Got Code 3======");

        //显示输入缓冲区数据
        DbgPrint((PCSTR)buffer);
        //将输出缓冲区填充字符
        RtlFillMemory(buffer, out_size, 0xF1);
        break;

    default:
        status = STATUS_INVALID_VARIANT;
        //如果是没有处理的IRP，则返回STATUS_INVALID_VARIANT，这意味着用户模式的I/O函数失败，但并不会设置GetLastError
    }

    // 完成IRP
    pIrp->IoStatus.Status = status;//设置IRP完成状态，会设置用户模式下的GetLastError
    pIrp->IoStatus.Information = out_size;//设置操作的字节
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);//完成IRP，不增加优先级
    return status;
}

/*
    NTSTATUS DriverEntry(
        PDRIVER_OBJECT pDriverObject,  系统发来的驱动对象的指针
        PUNICODE_STRING pRegistryPath  一个内核字符串对象的指针，是驱动的服务名称
    )
*/
NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pRegistryPath) 
{
    DbgPrint("======Driver Load!======");
    pDriverObject->DriverUnload = DriverUnload;//注册驱动卸载函数

    //注册派遣函数
    pDriverObject->MajorFunction[IRP_MJ_CREATE] = DefaultDispatchRoutine;
    pDriverObject->MajorFunction[IRP_MJ_CLOSE] = DefaultDispatchRoutine;
    pDriverObject->MajorFunction[IRP_MJ_WRITE] = DefaultDispatchRoutine;
    pDriverObject->MajorFunction[IRP_MJ_READ] = DefaultDispatchRoutine;
    //IRP_MJ_DEVICE_CONTROL这个IRP在Win32子系统中调用DeviceIoControl生成，在NT Native层或内核模式下应该使用ZwDeviceIoControlFile
    pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = IoctlDispatchRoutine;

    NTSTATUS status;
    PDEVICE_OBJECT pDevObj; //设备句柄
    PDEVICE_EXTENSION pDevExt;

    //创建设备名称的字符串
    //最好写Device后面跟着名字，因为这个存放的位置是二叉树
    UNICODE_STRING devName;
    RtlInitUnicodeString(&devName, L"\\Device\\HelloDevice");
    
    //创建设备
    /*
        NTSTATUS IoCreateDevice(
            IN PDRIVER_OBJECT  DriverObject,    //驱动对象
            IN ULONG  DeviceExtensionSize,    //设备扩展大小，将为设备对象和设备扩展对象在非分页内存池内申请内存
            IN PUNICODE_STRING  DeviceName  OPTIONAL,    //设备在0环的名字，为NULL会自动分配数字
            IN DEVICE_TYPE  DeviceType,        //设备类型
            IN ULONG  DeviceCharacteristics,//设备属性
            IN BOOLEAN  Exclusive,            //是否独占
            OUT PDEVICE_OBJECT  *DeviceObject    //输出一个设备对象注意是二级指针
        );
    */
    status = IoCreateDevice(
        pDriverObject, 
        sizeof(DEVICE_EXTENSION), //为设备扩展分配内存
        &devName, 
        FILE_DEVICE_UNKNOWN, //不是真正的硬件驱动，填FILE_DEVICE_UNKNOWN
        0, 
        TRUE, 
        &pDevObj
    );
    if (!NT_SUCCESS(status))
    {
        DbgPrint("======Call IoCreateDevice Failed!======");
        return status;
    }

    pDevObj->Flags |= DO_BUFFERED_IO;//将设备设置为缓冲I/O设备
    pDevExt = (PDEVICE_EXTENSION)pDevObj->DeviceExtension;//得到设备扩展

    //创建符号链接
    UNICODE_STRING symLinkName;
    RtlInitUnicodeString(&symLinkName, L"\\??\\HelloDevice_lnk");
    pDevExt->SymLinkName = symLinkName;
    status = IoCreateSymbolicLink(&symLinkName, &devName);
    if (!NT_SUCCESS(status))
    {
        DbgPrint("======Call IoCreateSymbolicLink Falied!======");
        IoDeleteDevice(pDevObj);
        return status;
    }

    return STATUS_SUCCESS;
}
```

##### ring3程序部分

```c
#include <windows.h>
#include <tchar.h>
#include <stdio.h>

#define IOCTL1 CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)

int _tmain(int argc, _TCHAR* argv[])
{
    HANDLE handle = CreateFileA("\\\\.\\HelloDevice_lnk", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (handle == INVALID_HANDLE_VALUE) {
        MessageBoxA(0, "打开设备失败", "错误", 0);
        return 0;
    }
    unsigned char buffer[50] = { 0 };
    unsigned char buffer2[50] = { 0 };
    DWORD len;
    sprintf_s((char*)buffer, 50, "hello, driver\r\n");
    if (DeviceIoControl(handle, IOCTL1, buffer, strlen((char*)buffer), buffer2, 49, &len, NULL)) {
        printf("len: %d\n", len);
        for (int i = 0; i < len; i++) {
            printf("0x%02X ", buffer2[i]);
        }
    }
    getchar();
    CloseHandle(handle);
    return 0;
}

```

#### 跨进程访问

> 设计驱动和用户程序，实现用户程序访问其他进程文件句柄，并直接对句柄进行操作
> 设计模拟环境：simple.exe读写权限打开一个文件，持续读取文件内容输出，编写r3程序和驱动获取到该句柄并改写文件内容

simpleFile.c

```c
#include <stdio.h>
#include <windows.h>
#include <io.h>
#include <fcntl.h>

int main() {
    LPCWSTR lpFilename = L"hello.txt";
    HANDLE hFile = CreateFile(
        lpFilename,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_SYSTEM,
        NULL
    );
    if (hFile == NULL) {
        printf("CreateFile error!\n");
        return 1;
    }
    printf("CreateFile success!\n");
    int fileSize = GetFileSize(hFile, NULL);
    char buffer[50] = {'a'};
    DWORD read_num = -1;
    FILE* pFile = NULL;
    int osf = _open_osfhandle((intptr_t)hFile, O_RDWR);
    if (osf != -1) {
        printf("convert HANDLE to FILE* success\n");
        pFile = _fdopen(osf, "w+");
    }
    
    while (pFile) 
    {
        fread(buffer, sizeof(char), fileSize, pFile);
        fseek(pFile, 0, SEEK_SET);
        /*ReadFile(hFile, buffer, GetFileSize(hFile, NULL), &read_num, NULL);*/
        printf("%s\n", buffer);
        memset(buffer, 0x41, fileSize);
        Sleep(1000);
    }
    CloseHandle(hFile);
    return 0;
}
```

- 写完发现需求理解错了，simple.c没必要这么麻烦，目的只是通过驱动去遍历内核句柄，找到目标文件再打开，r3程序也不需要，文件的操作全都放在驱动里完成。
- 总体思路:利用`ZwQuerySystemInformation`,遍历进程,获取每个进程的句柄表,再遍历句柄表,使用枚举`_SYSTEM_INFORMATION_CLASS`的`SystemHandleInformation`(对应数字16),
- 相关数据结构见[附录A](#appendix-a)



## Appendix A

> 驱动相关

### _SYSTEM_INFORMATION_CLASS

```c
typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation,// 0 Y N
    SystemProcessorInformation,// 1 Y N
    SystemPerformanceInformation,// 2 Y N
    SystemTimeOfDayInformation,// 3 Y N
    SystemNotImplemented1,// 4 Y N // SystemPathInformation
    SystemProcessesAndThreadsInformation,// 5 Y N
    SystemCallCounts,// 6 Y N
    SystemConfigurationInformation,// 7 Y N
    SystemProcessorTimes,// 8 Y N
    SystemGlobalFlag,// 9 Y Y
    SystemNotImplemented2,// 10 YN // SystemCallTimeInformation
    SystemModuleInformation,// 11 YN
    SystemLockInformation,// 12 YN
    SystemNotImplemented3,// 13 YN // SystemStackTraceInformation
    SystemNotImplemented4,// 14 YN // SystemPagedPoolInformation
    SystemNotImplemented5,// 15 YN // SystemNonPagedPoolInformation
    SystemHandleInformation,// 16 YN
    SystemObjectInformation,// 17 YN
    SystemPagefileInformation,// 18 YN
    SystemInstructionEmulationCounts,// 19 YN
    SystemInvalidInfoClass1,// 20
    SystemCacheInformation,// 21 YY
    SystemPoolTagInformation,// 22 YN
    SystemProcessorStatistics,// 23 YN
    SystemDpcInformation,// 24 YY
    SystemNotImplemented6,// 25 YN // SystemFullMemoryInformation
    SystemLoadImage,// 26 NY // SystemLoadGdiDriverInformation
    SystemUnloadImage,// 27 NY
    SystemTimeAdjustment,// 28 YY
    SystemNotImplemented7,// 29 YN // SystemSummaryMemoryInformation
    SystemNotImplemented8,// 30 YN // SystemNextEventIdInformation
    SystemNotImplemented9,// 31 YN // SystemEventIdsInformation
    SystemCrashDumpInformation,// 32 YN
    SystemExceptionInformation,// 33 YN
    SystemCrashDumpStateInformation,// 34 YY/N
    SystemKernelDebuggerInformation,// 35 YN
    SystemContextSwitchInformation,// 36 YN
    SystemRegistryQuotaInformation,// 37 YY
    SystemLoadAndCallImage,// 38 NY // SystemExtendServiceTableInformation
    SystemPrioritySeparation,// 39 NY
    SystemNotImplemented10,// 40 YN // SystemPlugPlayBusInformation
    SystemNotImplemented11,// 41 YN // SystemDockInformation
    SystemInvalidInfoClass2,// 42 // SystemPowerInformation
    SystemInvalidInfoClass3,// 43 // SystemProcessorSpeedInformation
    SystemTimeZoneInformation,// 44 YN
    SystemLookasideInformation,// 45 YN
    SystemSetTimeSlipEvent,// 46 NY
    SystemCreateSession,// 47 NY
    SystemDeleteSession,// 48 NY
    SystemInvalidInfoClass4,// 49
    SystemRangeStartInformation,// 50 YN
    SystemVerifierInformation,// 51 YY
    SystemAddVerifier,// 52 NY
    SystemSessionProcessesInformation// 53 YN
} SYSTEM_INFORMATION_CLASS;
```

### _SYSTEM_HANDLE_TYPE

```c
typedef enum _SYSTEM_HANDLE_TYPE{
    OB_TYPE_UNKNOWN,         // 0,未知类型
    OB_TYPE_TYPE,            // 1,类型
    OB_TYPE_DIRECTORY,       // 2,目录
    OB_TYPE_SYMBOLIC_LINK,   // 3,符号链接
    OB_TYPE_TOKEN,           // 4,安全
    OB_TYPE_PROCESS,         // 5,进程
    OB_TYPE_THREAD,          // 6,线程
    OB_TYPE_JOB,             // 7,Job
    OB_TYPE_DEBUG_OBJECT,    // 8,调试对象
    OB_TYPE_EVENT,           // 9,事件
    OB_TYPE_EVENT_PAIR,      // 10,事件
    OB_TYPE_MUTANT,          // 11,互斥体
    OB_TYPE_CALLBACK,        // 12,回调
    OB_TYPE_SEMAPHORE,       // 13,信号量
    OB_TYPE_TIMER,           // 14,时钟
    OB_TYPE_PROFILE,         // 15,Profile
    OB_TYPE_KEYED_EVENT,     // 16,键盘事件
    OB_TYPE_WINDOWS_STATION, // 17,fixed
    OB_TYPE_DESKTOP,         // 18,桌面
    OB_TYPE_SECTION,         // 19,共享内存区
    OB_TYPE_KEY,             // 20,键值
    OB_TYPE_PORT,            // 21,端口
    OB_TYPE_WAITABLE_PORT,   // 22,可等待端口
    OB_TYPE_ADAPTER,         // 23,适配器
    OB_TYPE_CONTROLLER,      // 24,控制器
    OB_TYPE_DEVICE,          // 25,设备
    OB_TYPE_DRIVER,          // 26,驱动
    OB_TYPE_IOCOMPLETION,    // 27,fixed
    OB_TYPE_FILE,            // 28,内存映射文件
    OB_TYPE_WMIGUID          // 29,fixed
} SYSTEM_HANDLE_TYPE;
```

### _SYSTEM_HANDLE_TABLE_ENTRY_INFO

```c
typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
    USHORT UniqueProcessId;//所属进程
    USHORT CreatorBackTraceIndex;
    UCHAR ObjectTypeIndex;
    UCHAR HandleAttributes;
    USHORT HandleValue; //句柄
    PVOID Object;
    ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;
```

### _SYSTEM_HANDLE_INFORMATION

```c
typedef struct _SYSTEM_HANDLE_INFORMATION
{
    ULONG NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;
```

### _SYSTEM_HANDLE_INFORMATION*

```c
typedef struct _SYSTEM_HANDLE_INFORMATION{
    ULONG                ProcessId;
    UCHAR                ObjectTypeNumber;
    UCHAR                Flags;
    USHORT               Handle;
    PVOID                Object;
    ACCESS_MASK          GrantedAccess;
    /*
    ProcessId:           进程标识符
    ObjectTypeNumber;    打开的对象的类型
    Flags:               句柄属性标志
    Handle:              句柄数值,在进程打开的句柄中唯一标识某个句柄
    Object:              这个就是句柄对应的EPROCESS的地址
    GrantedAccess:       句柄对象的访问权限
    */
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;
```
