# 实习笔记

## windows驱动开发

> 环境：vs2019 + VMware-win7(kdm manager + debugview) + win7串口调试
> win10 SDK+WDK

### 环境配置

#### 开发环境

- WDK会自动安装VS插件，但实际在安装时没有自动安装，解决办法为从安装目录下找到插件手动安装
- 需要修改win7的注册表文件，在`HKLM\SYSTEM\CuurentControlSet\Control\Session Manager`下创建或打开`Debug Print Filter`，创建项`DEFAULT`，值为0xf

```reg
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Debug Print Filter] 
"DEFAULT"=dword:0000000f
```

- 新建WDM项目后，进行如下默认属性修改：
  - 链接器：将链接器警告视为错误 -> 否
  - Driver Settings：目标OS版本 -> windows 7；目标平台 -> Desktop
  - Inf2Cat：Run Inf2Cat -> 否
  - C/C++ -- 常规：警告等级 -> W3；将警告视为错误：否

- 注意源码文件后缀设置为.c
- 开发win7下win32应用需要VS安装.NET 3.5的开发工具包

#### 调试环境

1. 为win7虚拟机添加串口设备（虚拟机设置里），记住端口号，默认应该是2（1是打印机，也可以删掉打印机，用1表示串口）
2. 在win7下cmd输入`bcdedit /copy {current} /d DebugEntry`，这里的DebugEntry可以随意替换名称
3. 打开msconfig--引导，配置DebugEntry的引导高级选项，勾选调试，设置调试端口为前面设置的端口号，波特率默认115200即可，设置好后重启选择系统即可进入调试模式
4. 创建调试机下windbg快捷方式，添加启动参数，如`"C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\windbg.exe" -b -k com:pipe,port=\\.\pipe\com_1,resets=0,reconnect -y`
5. 之后启动windbg等待连接即可

### 驱动基础

#### 写文件

```c
#include <ntddk.h>

VOID DriverUnload(PDRIVER_OBJECT pDriver)
{
    UNREFERENCED_PARAMETER(pDriver);
    DbgPrint("=====Driver unload success=====\n");
}

NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING pRegPath)
{
    DbgPrint("=====Driver load success=====\n");
    HANDLE hFile = NULL;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS ntStatus;

    ////创建对象
    OBJECT_ATTRIBUTES oa;
    UNICODE_STRING file_path;
    RtlInitUnicodeString(&file_path, L"\\??\\c:\\test.log");
    ////初始化对象
    InitializeObjectAttributes(&oa, &file_path, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL);

    ////创建文件
    ntStatus = ZwCreateFile(
        &hFile,
        GENERIC_READ | GENERIC_WRITE,
        &oa,
        &ioStatus,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ,
        FILE_OPEN_IF,
        FILE_NON_DIRECTORY_FILE | FILE_RANDOM_ACCESS |  FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0);

    ////写文件
    ntStatus = ZwWriteFile(
        hFile,
        NULL,
        NULL,
        NULL,
        &ioStatus,
        file_path.Buffer,
        file_path.Length,
        NULL,
        NULL
    );
    ZwClose(hFile);
    DbgPrint("=====Create file success=====\n");
    pDriver->DriverUnload = DriverUnload;
    return STATUS_SUCCESS;
}
```

#### DeviceIoControl练习

子系统及其本机应用程序只能通过 i/o 管理器提供的**文件对象句柄**访问驱动程序的设备或大容量存储设备上的文件。 若要打开此类文件对象或获取设备或数据文件的 i/o 句柄，子系统将**使用请求打开命名文件来调用 i/o 系统服务**。 命名文件可以具有特定于子系统的别名 (符号链接) 到 file 对象的内核模式名称。

##### 定义ctl码

```c
#define CTL_CODE(DeviceType, Function, Method, Access) (((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method))
```

- DeviceType：设备类型，IoCreateDevice使用的设备类型
- Function：定义设备类别中的一个操作。0-2047和4096以后被微软保留，2048-4095（0x800-0xFFF）可用
- Method：定义操作模式
  - METHOD_BUFFERED：缓冲区方法
  - METHOD_IN_DIRECT：直接输入
  - METHOD_OUT_DIRECT：直接输出
  - METHOD_NEITHER：两者都不，即其他方法
  - 对于 Windows 嵌入式设备，此字段将被忽略。始终使用 METHOD_BUFFERED。
- Access：一般用FILE_ANY_ACCESS，所有权限。

##### 基本概念

`PDEVICE_OBJECT DeviceObject`：指向第一个设备对象的指针。一个驱动可以创建多个“设备”，这个成员是指向第一个设备对象的指针。驱动程序可以使用此成员和 DEVICE_OBJECT 的 NextDevice 成员来逐句通过驱动程序创建的所有设备对象的列表。
`UNICODE_STRING DriverName`：驱动名称，是 UNICODE_STRING 字符串。
`PDRIVER_DISPATCH MajorFunction`：派遣函数的指针。应视作一个数组，用以注册派遣函数，
`PDRIVER_UNLOAD DriverUnload`：驱动卸载函数的指针。指向一个卸载函数，驱动卸载时负责清理工作，应在这个函数中关闭打开的句柄、释放申请的内存，防止内存泄露。如果驱动程序不注册卸载函数，那么驱动一旦加载就无法卸载。

##### 驱动部分

```c
#include <ntddk.h>

#define IOCTL1 CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL2 CTL_CODE(FILE_DEVICE_UNKNOWN,0x801,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL3 CTL_CODE(FILE_DEVICE_UNKNOWN,0x802,METHOD_BUFFERED,FILE_ANY_ACCESS)

typedef struct _DEVICE_EXTENSION {
    UNICODE_STRING SymLinkName;
} DEVICE_EXTENSION, * PDEVICE_EXTENSION;

VOID DriverUnload(PDRIVER_OBJECT pDriverObject) {
    PDEVICE_OBJECT pDevObj;
    pDevObj = pDriverObject->DeviceObject; // 

    PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)pDevObj->DeviceExtension;//得到设备扩展

    //删除符号链接
    UNICODE_STRING pLinkName = pDevExt->SymLinkName;
    IoDeleteSymbolicLink(&pLinkName);

    //删除设备
    IoDeleteDevice(pDevObj);

    DbgPrint("======Driver Unload!======");
}

NTSTATUS DefaultDispatchRoutine(PDEVICE_OBJECT pDevObj, PIRP pIrp)
{
    NTSTATUS status = STATUS_SUCCESS;
    pIrp->IoStatus.Status = status;
    pIrp->IoStatus.Information = 0;
    // 当驱动完成了对指定IRP的所有处理操作之后，会调用 IoCompleteRequest
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    return status;
}

NTSTATUS IoctlDispatchRoutine(PDEVICE_OBJECT pDevObj, PIRP pIrp)
{
    DbgPrint("Enter IoctlDispatchRoutine\r\n");
    NTSTATUS status = STATUS_SUCCESS;

    //得到I/O堆栈的当前这一层，也就是IO_STACK_LOCATION结构的指针
    PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(pIrp);

    ULONG in_size = stack->Parameters.DeviceIoControl.InputBufferLength;//得到输入缓冲区的大小
    ULONG out_size = stack->Parameters.DeviceIoControl.OutputBufferLength;//得到输出缓冲区的大小
    ULONG code = stack->Parameters.DeviceIoControl.IoControlCode;//得到控制码

    PVOID buffer = pIrp->AssociatedIrp.SystemBuffer;//得到缓冲区指针

    switch (code)
    {                        // process request
    case IOCTL1:
        DbgPrint("======Got Code 1======");
    case IOCTL2:
        DbgPrint("======Got Code 2======");
    case IOCTL3:
        DbgPrint("======Got Code 3======");

        //显示输入缓冲区数据
        DbgPrint((PCSTR)buffer);
        //将输出缓冲区填充字符
        RtlFillMemory(buffer, out_size, 0xF1);
        break;

    default:
        status = STATUS_INVALID_VARIANT;
        //如果是没有处理的IRP，则返回STATUS_INVALID_VARIANT，这意味着用户模式的I/O函数失败，但并不会设置GetLastError
    }

    // 完成IRP
    pIrp->IoStatus.Status = status;//设置IRP完成状态，会设置用户模式下的GetLastError
    pIrp->IoStatus.Information = out_size;//设置操作的字节
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);//完成IRP，不增加优先级
    return status;
}

/*
    NTSTATUS DriverEntry(
        PDRIVER_OBJECT pDriverObject,  系统发来的驱动对象的指针
        PUNICODE_STRING pRegistryPath  一个内核字符串对象的指针，是驱动的服务名称
    )
*/
NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pRegistryPath) 
{
    DbgPrint("======Driver Load!======");
    pDriverObject->DriverUnload = DriverUnload;//注册驱动卸载函数

    //注册派遣函数
    pDriverObject->MajorFunction[IRP_MJ_CREATE] = DefaultDispatchRoutine;
    pDriverObject->MajorFunction[IRP_MJ_CLOSE] = DefaultDispatchRoutine;
    pDriverObject->MajorFunction[IRP_MJ_WRITE] = DefaultDispatchRoutine;
    pDriverObject->MajorFunction[IRP_MJ_READ] = DefaultDispatchRoutine;
    //IRP_MJ_DEVICE_CONTROL这个IRP在Win32子系统中调用DeviceIoControl生成，在NT Native层或内核模式下应该使用ZwDeviceIoControlFile
    pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = IoctlDispatchRoutine;

    NTSTATUS status;
    PDEVICE_OBJECT pDevObj; //设备句柄
    PDEVICE_EXTENSION pDevExt;

    //创建设备名称的字符串
    //最好写Device后面跟着名字，因为这个存放的位置是二叉树
    UNICODE_STRING devName;
    RtlInitUnicodeString(&devName, L"\\Device\\HelloDevice");
    
    //创建设备
    /*
        NTSTATUS IoCreateDevice(
            IN PDRIVER_OBJECT  DriverObject,    //驱动对象
            IN ULONG  DeviceExtensionSize,    //设备扩展大小，将为设备对象和设备扩展对象在非分页内存池内申请内存
            IN PUNICODE_STRING  DeviceName  OPTIONAL,    //设备在0环的名字，为NULL会自动分配数字
            IN DEVICE_TYPE  DeviceType,        //设备类型
            IN ULONG  DeviceCharacteristics,//设备属性
            IN BOOLEAN  Exclusive,            //是否独占
            OUT PDEVICE_OBJECT  *DeviceObject    //输出一个设备对象注意是二级指针
        );
    */
    status = IoCreateDevice(
        pDriverObject, 
        sizeof(DEVICE_EXTENSION), //为设备扩展分配内存
        &devName, 
        FILE_DEVICE_UNKNOWN, //不是真正的硬件驱动，填FILE_DEVICE_UNKNOWN
        0, 
        TRUE, 
        &pDevObj
    );
    if (!NT_SUCCESS(status))
    {
        DbgPrint("======Call IoCreateDevice Failed!======");
        return status;
    }

    pDevObj->Flags |= DO_BUFFERED_IO;//将设备设置为缓冲I/O设备
    pDevExt = (PDEVICE_EXTENSION)pDevObj->DeviceExtension;//得到设备扩展

    //创建符号链接
    UNICODE_STRING symLinkName;
    RtlInitUnicodeString(&symLinkName, L"\\??\\HelloDevice_lnk");
    pDevExt->SymLinkName = symLinkName;
    status = IoCreateSymbolicLink(&symLinkName, &devName);
    if (!NT_SUCCESS(status))
    {
        DbgPrint("======Call IoCreateSymbolicLink Falied!======");
        IoDeleteDevice(pDevObj);
        return status;
    }

    return STATUS_SUCCESS;
}
```

##### ring3程序部分

```c
```
